[useState, useEffect, useLayoutEffect, useRef, useContext, useReducer, useMemo, useCallback, custom Hooks].




1] What is Hooks =>
Hooks were added to React in version 16.8, before this version we can't use hooks topics.
Hooks are basically functions that let us "hook into" React state & lifecycle features from function components.
Before Hooks we were having class components for state management & lifecycle methods.

eg. class App extends React.Component {
    constructor(props){
        super(props);
        this.state = {message: "Hello, world!"};
    }
    render() {
        <h1>{this.state.message}</h1>
    }
}

line 11: Declares App class as a child of React Component class.
line 12-15: Initiates App class values & calls parent class constructor via super keyword using props.
line 14: Declares the state object values for App component.
line 16-18: Render function is declared & called when rendering React Elements.
line 17: Component state value referenced in render.


LifeCycle Methods ->

a) Initializtion = setup props & state.
b) Mounting = componentWillMount() --> render() --> componentDidMount().
c) Updation = 
c.1) props =  componentWillReceiveProps() --> shouldComponentUpdate() --> componentWillUpdate() --> render() --> componentDidUpdate()
c.2) states = shouldComponentUpdate() --> componentWillUpdate() --> render() --> componentDidUpdate()
d) Unmounting = componentWillUnmount()





2] Why Hooks? =>

React Hooks were introduced by the React team at React Conf in late October 2018 as a way to use state and lifecycle methods in functional components.
They were finally introduced in React v16.8.0 in early February 2019.
Hooks allow function components to have access to state and other React features, making class components generally no longer needed.
Although Hooks generally replace class components, there are no plans to remove classes from React.





3] Rules =>
We must import Hooks from react for using.
Hooks can only be called inside React function components.
Hooks can only be called at the top level of a component.
Hooks cannot be conditional.





4.1] useState =>
useState Hook allows us to track state in a function component. State generally refers to data or properties that need to be tracking in an application. 
useState accepts an initial state and returns two values/elements in array: The current state; A function that updates the state.


a] import ->

a) const [value, setValue] = React.useState();

b) import { useState } from "react";  //Notice that we are destructuring useState from react as it is a named export.
const [value, setValue] = useState();


b] Syntax ->

const [value, setValue] = useState(0);

Above eg. 0 = initial value of state variable(eg. value). value = current state. setValue = function which updates the state.
These names are variables that can be named anything we would like.


For update our state we use our state updator function.
We should never directly update state. Ex: color = "red" is not allowed.


c] What can state hold ->
The useState Hook can be used to keep track of strings, numbers, booleans, arrays, objects, and any combination of these.
We could create multiple state Hooks to track individual values.

useState(), useState(5), useState(""), useState("Raj"), useState(null), useState(true), useState([]), useState({}), useState(undefined)....


Updating Objects & Arrays in State -
 const [car, setCar] = useState({
    brand: "Ford",
    model: "Mustang",
    year: "1964",
    color: "red"
  });

If we only called setCar({color: "blue"}), this would remove the brand, model, and year from our state.

So to solve this we can use spread operator.
  const updateColor = () => {
    setCar(previousState => {
      return { ...previousState, color: "blue" }
    });
  }

Because we need the current value of state, we pass a function into our setCar function. This function receives the previous value.
We then return an object, spreading the previousState and overwriting only the color.





